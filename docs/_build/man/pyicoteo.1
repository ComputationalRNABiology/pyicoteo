.TH "PYICOTEO" "1" "June 25, 2013" "2.0" "pyicoteo"
.SH NAME
pyicoteo \- pyicoteo Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.\" Man page generated from reStructuredText.
.
.sp
Pyicoteo* is a suite of tools for the analysis of high\-throughput sequencing data. It works with genomic coordinates, it was mainly developed using Solexa/Illumina mapped reads, but in its core it is platform\-agnostic. There are currently 6 different tools for the analysis of HTS data: 5 command\-line based tools, which are: \fIPyicos\fP for genomic coordinates manipulation, \fIPyicoller\fP for peak calling on punctuated ChIP\-Seq, \fIPyicoenrich\fP for differential enrichment between two conditions, \fIPyicoclip\fP for calling CLIP\-Seq peaks without a control, \fIpyicoregion\fP for generating exploratory regions automatically.
.sp
Pyicoteo suite also includes one \fIconfiguration file based\fP and a \fIpython library\fP for scripting using HTS data:
.sp
Before start using it, it is highly recommended that you have a look at the \fIintro\fP document:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
* Pronounced as in Spanish  "picoteo"_ /pɪkɒtɛɒ/:
  (n) Appetizer\-type foods that accompany drinks before or instead of a meal.
.ft P
.fi
.UNINDENT
.UNINDENT
.SH TABLE OF CONTENTS
.SS Getting Started
.SS Download & Install
.sp
\fBDownload Pyicoteo\fP  \fI\%Latest version\fP from our repository.
.sp
You can also download older versions (up to 1.1b) from our \fI\%Sourceforge repository\fP.
.sp
The command line tools can be used directly without installation. However, installation is recommended, and necessary if you intend to use the Pyicoteolib. To do so decompress the folder and run the setup.py script with administrator privileges:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
python setup.py install
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Check installation
.sp
To test that the software was installed correctly, start a python console and try importing it by typing:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
python
>>> import pyicoteolib
>>> import pyicoteolib.core
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Also, you should find the tools in your command line.
.sp
\fITip: If you are in a Unix\-like (GNU/Linux, FreeBSD, Mac) system, open a console, type "pyico" and tap TAB twice. You should see something like this\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicoclip        pyicoller        pyicos
pyicoenrich      pyicoregion      pyicotrocol
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Dependencies
.sp
In order to make it simple for the community, Pyicoteo basic functionality has no dependencies other than Python 2.6 or higher. However, there are two optional libraries you could install to obtain full functionality.
.SS Matplotlib
.sp
For plotting capabilities, it is necessary to install Matplotlib (> 1.0).
.SS Samtools
.sp
Also, for BAM reading, while we offer a native python implementation, you can ask Pyicoteo to read BAM using samtools with the flag \fB\-\-samtools\fP.
.sp
Pyicoteo is not compatible with Python 3.
.SS The bedpk format
.sp
Some Pyicoteo tools (Pyicos, Pyicoller and Pyicoclip) default experiment and output formats is a derivative of UCSC \fI\%Bed format\fP called bedpk. It follows the same starting fields "chromosome/tag start end" but it uses some of the original optional fields to include extra information. It is a cluster oriented format that aims to recollect information of a cluster of reads in a single comprehensive line.
.INDENT 0.0
.INDENT 2.5
[image]
The bedpk format specification. It is exactly like a BED6 format, but using the 4th column to store extra information about how the cluster was built..UNINDENT
.UNINDENT
.SS bedpk Column definition
.INDENT 0.0
.IP 1. 3
Chromosome
.IP 2. 3
Start coordinate
.IP 3. 3
End coordinate
.IP 4. 3
Profile: This field summarizes the accumulation of reads per nucleotide of the cluster. The first number is the number of bases covered, while the second will be the number of reads in those bases. See the example above
.IP 5. 3
Height: The maximum height of the cluster. In this case, 3.
.IP 6. 3
Strand: if ALL reads that  are positive strand \fB+\fP, if they are all negative \fB\-\fP. Otherwise \fB.\fP
.IP 7. 3
Summit: The position where the maximum height is found. The binding site is expected to be close to the summit.
.IP 8. 3
Area: The area covered by the cluster.
.IP 9. 3
p\-value: The significance of the cluster calculated by the poisson operation based on peak heights or numbers of reads.
.UNINDENT
.SS General and important flags
.SS Disk usage flags
.sp
The tools in Pyicoteo Suite follow the principle of minimal memory usage. Because of this, Pyicoteo makes heavy use of disk and temporary files. You should make sure that you have at least double the space of each file in your hard drive before using Pyicoteo. Also, please take into consideration the following flags:
.SS \fB\-\-tempdir\fP
.sp
Pyicoteo uses the default temporary directory in the system (in many Unix based system, the content of the variable $TEMPDIR, normally /tmp). You can change the temporary directory with this flag.
.SS \fB\-\-keep\-temp\fP
.sp
Pyicoteo tries to delete all unnecesary temporary files. If you want to keep the files in order to check them reuse them (for example, the sorted files could be useful in combination of the \fB\-\-no\-sort\fP flag) or delete them, use this flag
.SS \fB\-\-postscript\fP
.sp
If you want to get a postscript output on your plots instead of png.
.SS \fB\-\-showplots\fP
.sp
To launch matplotlib interactive mode instead of saving the resulting plot.
.SS Questions and Support
.sp
If you have any problems or suggestions please join the \fI\%Pyicoteo Google Group\fP and ask!
.SS Pyicos
.sp
Pyicos is a command line utility for the conversion and manipulation of genomic coordinates files. It follows a command/sub\-command structure
.sp
In the interactive help you can visualize the available commands list:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicos \-h
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you are interested in the usage of a particular command (for example, \(aqextend\(aq) and the meaning of its flags type:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicos extend \-h
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Here we explain briefly what each subcommand does and we give some examples:
.SS convert
.sp
Converting a file from one format to another format. Currently supported formats are:
.sp
experiment: Bed, Wiggle files (bed_wiggle), SAM, BAM, Eland, bedpk (Pyicos default compressed format), bedspk (Pyicos stranded compressed format)
.sp
output: Bed, Wiggle files (bed_wiggle, variable_wiggle), SAM, BAM, Eland, bedpk (Pyicos default compressed format), bedspk (Pyicos stranded compressed format)
.sp
This operation is useful if you only want to convert your data to another format. Other operations already include a conversion if you specify different experiment and output formats.
.sp
Convert a bed file to a half\-open variable wig file:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicos convert my_experiment.bed my_experiment.wig \-f bed \-F variable_wig \-O
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Convert all pk files in a folder to bed wig files:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicos convert my_experiment_folder/ outputfolder/ \-f pk \-F bed_wig
.ft P
.fi
.UNINDENT
.UNINDENT
.SS remregions
.sp
Remove regions that overlap with the regions in the "black list" file.
.sp
Example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicos remregions my_experiment.bed regions.bed my_result.bed \-\-experiment\-format bed \-\-open\-experiment \-\-region\-format bed \-\-open\-region \-\-output\-format bed \-\-open\-output
.ft P
.fi
.UNINDENT
.UNINDENT
.SS remduplicates
.sp
Remove the duplicated reads in a file. A duplicate is a read with the same start position as a read that has already been seen. You can choose how many duplicates you want to tolerate. If you want to keep only one read for a start position, set the duplicates to 0.
.sp
Example:
.sp
Here we tolerate 1 duplicate so a read can not occur more often than twice:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicos remduplicates my_experiment.bed my_experiment_1dupl.bed \-\-duplicates 1 \-f bed \-o \-F bed
.ft P
.fi
.UNINDENT
.UNINDENT
.SS strcorr (Strand Correlation)
.sp
Finds the optimal extension value by finding the "gap" between groups of positive and negative cluster of reads by performing a pearson correlation test.
.SS extend
.sp
Extend the reads to the estimated fragment length, taking into consideration if they map to the forward or reverse strand of the reference genome.
.INDENT 0.0
.INDENT 2.5
[image]
.UNINDENT
.UNINDENT
.sp
Examples:
.sp
We have a bed file (half open) with reads between 30 and 50 nucleotides long. We want to extend them all to 150 nucleotides and write the output in bedpk\-format to accelerate the successive operations:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicos extend my_experiment.bed my_experiment_ext.bedpk 150 \-f bed \-o
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
We do the same with the control:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicos extend control.bed control_ext.bedpk 150 \-f bed \-o
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To visualize the data in a genome browser we set the output to be half\-open bed_wig:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicos extend my_experiment.bed my_experiment_ext.bed_wig 150 \-f bed \-o \-F bed_wig \-O
.ft P
.fi
.UNINDENT
.UNINDENT
.SS subtract
.sp
Subtract the reads in one file from the reads in another file. Using background data (control) improves the results because the background distribution is not supposed to be normal,
and statistical approaches to obtain this have a limited reach.
.sp
The most straightforward approach is to subtract the control from the sample. Make sure the sample has been \fBnormalized\fP to the control beforehand!
Pyicos maintains a 1bp resolution by subtracting the reads nucleotide by nucleotide, rather than doing a statistical approximation.
Operating with directories will only give appropiate results if the files and the control are paired in alphabetical order.
.sp
Example:
.sp
Subtract the control from the experiment (both have already been extended, converted to bedpk and normalized):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicos subtract my_experiment_ext_norm.bedpk control_ext.bedpk my_experiment_ext_norm_subtr.bedpk
.ft P
.fi
.UNINDENT
.UNINDENT
.SS split
.sp
Split peaks into subpeaks in case they fulfill the criteria.
.sp
Criteria: peak has at least two neighboring maxima between which the coverage of reads falls below the threshold. The threshold can be set by the user and it reflects a proportion of the lower maximum.
.sp
Output: bedpk or Wiggle files
.INDENT 0.0
.INDENT 2.5
[image]
.UNINDENT
.UNINDENT
.sp
Example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicos split peaks.bedpk peaks_split.bedpk \-\-split\-proportion 0.9
.ft P
.fi
.UNINDENT
.UNINDENT
.SS discard
.sp
Discards peaks that look like artifacts due to the sequencing bias. Here we refer to peaks that look like blocks that result from duplicates (reads with the same start position).
.sp
Output: bedpk or Wiggle files
.INDENT 0.0
.INDENT 2.5
[image]
.UNINDENT
.UNINDENT
.sp
Example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicos discard peaks.bedpk peaks_discA.bedpk
.ft P
.fi
.UNINDENT
.UNINDENT
.SS poisson
.sp
This is the test to assess significance of peaks along the whole genome (as for ChIP\-Seq). We do 3 different global poisson statistical tests for each chromosome in a file:
.INDENT 0.0
.INDENT 3.5
\fBMax height analysis\fP
.sp
Lambda is calculated from the maximum heights of the clusters by calculating the average height of a cluster in a given region. Pyicos will obtain the p\-value_height of one cluster having a height k by chance.
.sp
\fBNumber of reads analysis\fP
.sp
Lambda is obtained from the number of reads in clusters.
.sp
\fBNucleotide analysis\fP
.sp
Lambda is obtained from the number of nucleotides in a cluster.
.UNINDENT
.UNINDENT
.sp
Example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicos poisson peaks.bedpk
.ft P
.fi
.UNINDENT
.UNINDENT
.SS filter
.sp
Detect and select significant clusters in the file. There are two steps in this operation: Through the poisson operation the thresholds are determined. Next the peaks are filtered according to these thresholds.
.sp
Output: bedpk or Wiggle files
.INDENT 0.0
.INDENT 2.5
[image]
.UNINDENT
.UNINDENT
.sp
Example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicos filter peaks.bedpk significant_peaks.bedpk 150
.ft P
.fi
.UNINDENT
.UNINDENT
.SS push
.sp
Push the reads in the corresponding strand. If a read doesn\(aqt have a strand, it will be pushed from left to right.
.sp
This operation requires tag\-like files (bed, eland, sam).
.sp
Example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicos push my_experiment.bed my_experiment_pushed100.bed 100 \-f bed \-F bed
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Credit
.INDENT 0.0
.IP \(bu 2
Developer: Juan González\-Vallinas
.IP \(bu 2
Beta Testing: Eneritz Agirre, Sonja Althammer, Juan González\-Vallinas
.IP \(bu 2
Supervision: Eduardo Eyras
.UNINDENT
.SS Pyicoller
.sp
This peak caller is a combination of some of Pyicos commands (extend, normalize, subtract, remove, poisson and filter) for the task of calling peaks from a ChIP\-Seq experiment (with narrow peaks). A control file is optional but recommended.
.sp
Example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicoller my_experiment.bed significant_peaks.bedpk \-f bed \-o \-\-control control.bed \-\-control\-format bed \-\-open\-control \-\-region regions_to_be_removed.bed \-\-remlabels chrY \-\-correction 0.8 \-\-k\-limit 20 \-\-p\-value 0.001 \-x 130
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Important flags
.sp
This is a description of the most important flags. To see the complete list of flags, type \fBpyicoller \-h\fP to get the full list.
.SS Credit
.INDENT 0.0
.IP \(bu 2
Developer: Juan González\-Vallinas
.IP \(bu 2
Beta testing: Sonja Althammer, Eneritz Agirre, Nuria Conde Pueyo
.IP \(bu 2
Optimization of the pipeline: Sonja Althammer
.IP \(bu 2
Benchmarking against other peak callers: Sonja Althammer
.IP \(bu 2
Performance benchmarking: Juan González\-Vallinas
.UNINDENT
.SS Pyicoenrich
.SS Introduction
.sp
Enrichment analysis can be applied on any type of \-seq data. Pyicoenrich performs enrichment analysis on sequenced reads from two conditions. Like this you can find out how significant the difference of these two conditions is, in terms of the number/density of reads overlapping a region of interest.
.INDENT 0.0
.INDENT 2.5
[image]
.UNINDENT
.UNINDENT
.SS MA Plot
.sp
Pyicoenrich is based on the \fI\%MA-Plot\fP.
.SS Region exploration
.sp
If a region file is provided, Pyicoenrich returns for each region a Z\-Score (See counts file description) which indicates the enrichment/depletion of condition A over condition B. If no region file is provided, Pyicoenrich provides the options to take the union of reads from both conditions as a region and gives back Z\-Scores for the generated regions. As regions with 0 reads in one condition might be especially interesting.
.sp
In order to decide what regions are to be explored, you have 3 main options:
.SS Generate a file with the \fB\-\-region\-magic\fP flag and GTF file
.sp
See the \fIPyicoregion\fP documentation for examples on how to use \fB\-\-region\-magic\fP flag to automatically explore exons, introns and the whole genome using sliding windows automatically generating your region files from standard GENCODE GTF files.
.SS Provide a regions file
.sp
If a region file is provided, Pyicoenrich returns for each region a z\-Score (among others) which indicates the enrichment/depletion of condition A over condition B. The region file should be in BED format. Also, you may consider only discontinuous regions by using the BED12 format:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicoenrich \-reads kidney1.bed liver1.bed \-output Pyicoenrich_Kidney_Liver_result_Counts \-f bed \-\-region genes.bed
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Do nothing
.sp
Don\(aqt really know where you want to look yet? If no region file is provided, Pyicoenrich will automatically generate one with taking he union of reads from both conditions as a region and gives back Z\-Scores for the generated regions.
.sp
The flag \fB\-\-proximity\fP controls the distance with which the regions are considered "joined". Default is 50nt:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicoenrich \-reads kidney1.bed liver1.bed \-output Pyicoenrich_Kidney_Liver_result \-f bed \-\-proximity 50nt
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 2.5
[image]
.UNINDENT
.UNINDENT
.SS \fB\-\-pseudocounts\fP flag
.sp
As regions with 0 reads in one condition might be especially interesting, Pyicoenrich can use pseudocounts, in order to avoid a division by 0: Pyicoenrich calculates the ratio of number of reads in both conditions. As there might not be any reads in a region, Pyicoenrich assumes that there is already 1 read in each region in each condition.
.SS \fB\-\-stranded\fP flag
.sp
To take into consideration reads that coincide with the strand direction of the regions (6th column in your BED6 file)
.SS Replica or technical control (swap)
.sp
To calculate the Z\-Score, Pyicoenrich compares the differences between condition A and condition B with the differences between A and A\(aq (while A\(aq is the biological replica of A). If no biological replica is available, Pyicoenrich uses a sample swap as a reference. With sample swap we mean that reads from condition A and B are mixed randomly and divided in two sets (with size of those of A and B). In the two resulting sets we do not expect any significant differences, just like in replicas.
.INDENT 0.0
.INDENT 2.5
[image]
Technical replica (swap) illustration.UNINDENT
.UNINDENT
.SS Examples
.sp
With replica:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicoenrich \-reads kidney1.bed liver1.bed \-output n_norm.enrich \-f bed \-\-region genes.bed \-\-replica kidney2.bed
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Using a swap:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicoenrich \-reads kidney1.bed liver1.bed \-output n_norm.enrich \-f bed \-\-region genes.bed
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description of the pyicoenrich counts file
.sp
Column description of enrichment result where each line describes a region:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
TIP: If you want to provide pyicoenrich with your own generated counts file, you only need to provide up to column 6)
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP 1. 4
name                    =  chromosome of region
.IP 2. 4
start                   =  region start
.IP 3. 4
end                     =  region end
.IP 4. 4
name2                   =  alternative label for the region, useful to put the gene name on it
.IP 5. 4
score                   =  Reserved by a "." as it is used by the UCSC browser for coloring.
.IP 6. 4
strand                  =  region strand
.IP 7. 4
signal_a                =  Counts in experiment A (normalized if used)
.IP 8. 4
signal_b                =  Counts in experiment B (normalized if used)
.IP 9. 4
signal_prime_1          =  Counts in experiment A (exactly the same as signal_a) or random background 1 (normalized if used)
.IP 10. 4
signal_prime_2         =  Counts in experiment replica A or random background 2 (normalized if used)
.IP 11. 4
A                      =  (log2(signal_a)+log2(signal_b))/2
.IP 12. 4
M                      =  log2(signal_a/signal_b)
.IP 13. 4
total_reads_a          =  total number of reads in sample a
.IP 14. 4
total_reads_b          =  total number of reads in sample b
.IP 15. 4
num_tags_a             =  number of reads in sample a overlapping the region
.IP 16. 4
num_tags_b             =  number of reads in sample b overlapping the region
.IP 17. 4
A_prime                =  (log2(signal_prime_1)+log2(signal_prime_2))/2
.IP 18. 4
M_prime                =  log2(signal_prime_1/signal_prime_2)
.IP 19. 4
total_reads_a          =  total number of reads in sample a
.IP 20. 4
total_reads_b          =  total number of reads in sample b
.IP 21. 4
total_reads_prime_1    =  total number of reads in sample prime 1
.IP 22. 4
total_reads_prime_2    =  total number of reads in sample prime 2
.IP 23. 4
A_median               =   median of A values in window
.IP 24. 4
mean                       =   mean of M_prime values in window
.IP 25. 4
sd                     =   standard deviation of M_prime values in window
.IP 26. 4
zscore                 =  score for the significance of the difference of enrichment between condition a and b compared to prime 1  and prime 2
.UNINDENT
.SS Normalization methods
.sp
Pyicoenrich included several popular normalization methods for the counts.
.INDENT 0.0
.INDENT 3.5
\fBPUBLIC SERVICE ANNOUNCEMENT:\fP When dealing with normalization methods, one has to be very careful.
There is no silver bullet, you need to understand your data and then apply the method that is appropriate for it.
If you are in doubt, please consult your local statistician.
.UNINDENT
.UNINDENT
.SS Total reads normalization (\fB\-\-n\-norm\fP)
.sp
This normalization will calculate the \fInumber of reads per million reads\fP in each region and sample. This is a \fIvery simple\fP normalization that tries to correct the bias of comparing different samples by total number of reads. You can activate it with the \fB\-\-n\-norm\fP flag.
.sp
Example. Using 2 reads files, calculate the enrichment normalizing by N
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicoenrich \-reads kidney1.bed liver1.bed \-output n_norm.enrich \-f bed \-\-region genes.bed \-\-n\-norm
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you want to skip the total reads calculation step, you can provide the total number of reads with the following flags.
.INDENT 0.0
.TP
.B \-\-total\-reads\-a
.UNINDENT
.INDENT 0.0
.TP
.B \-\-total\-reads\-b
.UNINDENT
.INDENT 0.0
.TP
.B \-\-total\-reads\-replica
.UNINDENT
.sp
Example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicoenrich \-reads kidney1.bed liver1.bed \-output n_norm.enrich \-f bed \-\-region genes.bed \-\-n\-norm \-\-total\-reads\-a 120000 \-\-total\-reads\-b 110000
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Region length normalization (\fB\-\-len\-norm\fP)
.sp
Calculates the number of reads per \fBregion\fP kilobase. It aims to correct for regions with different lengths.
.sp
NOTE: If possible, try not to mix regions with different lengths.
.sp
pyicoenrich \-reads kidney1.bed liver1.bed \-output n_norm.enrich \-f bed \-\-region genes.bed \-\-n\-norm
.SS RPKM (\fB\-\-len\-norm\fP and \fB\-\-n\-norm\fP)
.sp
The popular RPKM normalization is the combination of both \fB\-\-n\-norm\fP and \fB\-\-len\-norm\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicoenrich \-reads kidney1.bed liver1.bed \-output rpkm_norm.enrich \-f bed \-\-region genes.bed \-\-n\-norm \-\-len\-norm
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Trimmed Means of M values normalization (\fB\-\-tmm\-norm\fP)
.sp
As proposed by \fI\%EdgeR\fP.
.sp
This calculates the weighted trimmed mean of the log expression ratios (trimmed mean of M values (TMM)). It is based on the hypothesis that most of your regions do not change, and calculates a normalization factor by excluding the total amount of data.
.sp
Important flags.
.INDENT 0.0
.TP
.B \-\-a\-trim
Proportion of A values to be discarded when doing the
.sp
TMM normalization. [Default 0.05]
.UNINDENT
.INDENT 0.0
.TP
.B \-\-m\-trim
Proportion of M values to be discarded when doing the
.sp
TMM normalization. [Default 0.25]
.UNINDENT
.sp
Example: TMM normalization calculated discarding the 20% smaller A (less read coverage) and 5% of the regions with the biggest differences (up and down):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicoenrich \-reads kidney1.bed liver1.bed \-output rpkm_norm.enrich \-f bed \-\-region genes.bed \-\-tmm\-norm \-\-a\-trim 0.2 \-\-m\-trim 0.05
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Full quantile normalization (\fB\-\-quant\-norm\fP)
.sp
This method is suitable when your samples have too much variability. As eloquently put by \fI\%Simplystatistics\fP
.SS \fB\-\-interesting\-regions\fP
.sp
Providing a list of interesting regions matching the 4th column of the region or count file will highlight them in the MA plot.
.INDENT 0.0
.INDENT 2.5
[image]
Example of an enrichment output plot using \fB\-\-interesting\-regions\fP..UNINDENT
.UNINDENT
.sp
Example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"""
Region file (regions.bed)
chr1 1 100     region1 0 .
chr1 1000 1100 region2 0 .
chr2 1 100     region3 0 .
\&...
chrN x y       regionN 0 .

Interesting regions file (interreg.txt)
region4
region10
\&...
regionZ
"""
pyicoenrich \-reads kidney1.bed liver1.bed \-output rpkm_norm.enrich \-f bed \-\-region genes.bed \-\-interesting\-regions interreg.txt
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Credit
.INDENT 0.0
.IP \(bu 2
Developers: Juan González\-Vallinas, Ferran Lloret
.IP \(bu 2
Beta Testing: Sonja Althammer, Eneritz Agirre, Nuria Conde Pueyo, Juan González\-Vallinas
.IP \(bu 2
Benchmarking against other DE methods: Sonja Althammer
.IP \(bu 2
Speed and memory performance benchmarking: Juan González\-Vallinas
.IP \(bu 2
Supervision: Eduardo Eyras
.UNINDENT
.SS Pyicoclip
.SS Introduction
.sp
Pyicoclip is an implementation of the modified False Discovery Rate algorithm \fI\%proposed\fP by Yeo et al. to determine which clusters are significant in a list of genomic regions (like genes or transcripts). This method is typically used in CLIP\-Seq data that doesn\(aqt have a valid control experiment to compare against.
.sp
This method could in principle be used for any other kind of experiment that involves short reads and doesn\(aqt have a valid control. You can provide your own region file, or otherwise you can provide a \fB\-\-region\-magic\fP description with a GTF file (see below )
.SS Basic usage
.sp
\fBpyicoclip\fP usage requires the experiment CLIP\-Seq file (eland, SAM, BAM, BED formats) and a region file in BED format. Default output format is \fIThe bedpk format\fP, our extended but compatible with BED format.
.sp
Example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicoclip my_experiment.bed output.pk \-f bed \-\-region my_regions.bed
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command will output 2 files: \fBoutput.pk\fP and \fBunfiltered_output.pk\fP. In \fBoutput.pk\fP you will get the significant peaks after applying the method an the significant p\-value, in the unfiltered one you will get the unfiltered peaks with 2 or more overlapping reads.  Single reads are omitted from the output.
.SS Important flags
.sp
This is a description of the most important flags. To see the complete list of flags, type \fBpyicoclip \-h\fP to get the full list.
.SS \fB\-\-stranded\fP
.sp
You will probably want to use the \-\-stranded flag, in order to take into consideration reads only overlapping with the strand of the regions of interest (6th column of your BED6 region file):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicoclip my_experiment.bed output.pk \-f bed \-\-region my_regions.bed **\(ga\(ga\-\-stranded\(ga\(ga**
.ft P
.fi
.UNINDENT
.UNINDENT
.SS \fB\-\-p\-value\fP
.sp
The threshold to make it to the significant peaks list. Default is 0.01
.SS \fB\-\-region\-magic\fP and \fB\-\-gtf\-file\fP
.sp
You can automatically generate exploratory region files using the \fB\-\-region\-magic\fP and \fB\-\-gtf\-file\fP flags.
.sp
For example, explore the regions 500 bases upstream and 1000 downstream of TSS:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicoclip my_experiment.bed output.pk \-f bed \-\-region my_regions.bed \-\-gtf\-file myref.gtf \-\-region\-magic tss \-500 1000
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Check all genes:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicoclip my_experiment.bed output.pk \-f bed \-\-region my_regions.bed \-\-gtf\-file myref.gtf \-\-region\-magic genebody
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
See \fIPyicoregion\fP documentation for more details on how to use \fB\-\-region\-magic\fP flag.
.SS Credit
.INDENT 0.0
.IP \(bu 2
Developer: Juan González\-Vallinas
.IP \(bu 2
Beta Testing: Mireya Plass, Juan González\-Vallinas
.IP \(bu 2
Supervision: Eduardo Eyras
.UNINDENT
.SS Pyicoregion
.sp
Pyicoregion is a Pyicoteo module for processing region files.
.sp
It uses GFF files as specified in \fI\%http://www.sanger.ac.uk/resources/software/gff/spec.html\fP
.SS Pyicoregion arguments
.INDENT 0.0
.TP
.B \-\-region\-magic
.INDENT 7.0
.TP
.B exons [position]
Returns all the exons in the region file.
.sp
If the optional argument \fB[position]\fP is specified (possible values: \fBfirst\fP, \fBlast\fP), it will only return the first or last exon of every gene.
.UNINDENT
.INDENT 7.0
.TP
.B introns [position]
Returns all the introns in the region file.
.sp
If the optional argument \fB[position]\fP is specified (possible values: \fBfirst\fP, \fBlast\fP), it will only return the first or last intron of every gene.
.UNINDENT
.INDENT 7.0
.TP
.B slide <window_size> <window_step> <region_type> [chromlen_file_path]
Searches for intergenic and intragenic regions using sliding windows.
.sp
Mandatory arguments are \fB<window_size>\fP (the size of the sliding window), \fB<window_step>\fP (the distance between the start position of every consecutive window. It must be lower than or equal to the window size) and \fB<region_type>\fP (must be \fBinter\fP, for intergenic, or \fBintra\fP, for intragenic regions).
.sp
The optional argument \fB[chromlen_file_path]\fP is used to specify the path to the file containing the chromosome lengths (Pyicoteo\(aqs own chromlen files can be found in pyicoteolib/chromlen/). If it is not specified for intergenic regions, the results for the last regions of the chromosomes might be wrong.
.sp
Note: if the last segment of a region is shorter than the window size, the step distance is decreased by the difference (the window size stays the same).
.sp
Note: regions shorter than the window size are ignored.
.UNINDENT
.INDENT 7.0
.TP
.B tss <add_start> <add_end>
Returns the TSS for every transcript in the region file.
.sp
Due to a TSS being a single point, the arguments \fB<add_start>\fP and \fB<add_end>\fP specify the values added to the start and end of every TSS (taking into consideration the strand). For pyicoregion to work correctly, they must be non\-negative integers. Also, if the strand is not specified, the regions will be treated as if they were positive.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \-\-gff\-file <gff_file_path>
Used to specify the path of the GFF file containing the regions. This argument is mandatory for all operations involving regions.
.UNINDENT
.SS Credit
.INDENT 0.0
.IP \(bu 2
Developers: Ferran Lloret, Juan González\-Vallinas
.IP \(bu 2
Unit and beta Testing: Juan González\-Vallinas, Ferran Lloret
.IP \(bu 2
Supervision: Eduardo Eyras
.UNINDENT
.SS Pyicotrocol
.sp
Pyicotrocol offers access to the whole functionality of Pyicoteo, allowing for combination of operations in the different Pyicoteo suite tools.
.sp
It also has the nice advantage in terms of experiment reproducibility, since you don\(aqt need to save the command you used, what you did stays in the text file.
Execution
\-\-\-\-\-\-\-\-\-
.sp
To run a protocol file type:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pyicotrocol my_protocol.ini
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Syntax
.sp
Pyicotrocols files are based on the \fI\%.ini format\fP
.SS Examples
.sp
This example is equivalent of using pyicoller (To determine significant peaks; recommended for transcription factors)
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[Pyicotrocol]

; your files:
experiment          = my_experiment.bed
control             = control.bed
region              = regions_to_be_removed.bed

; format of all files:
experiment_format   = bed
control_format      = bed
region_format       = bed

; half\-open?
open_experiment     = true
open_control        = true
open_region         = true

; your result:
output              = significant_peaks.bedpk

; operations that will be applied:
operations          = remove_duplicates, remove, extend, normalize, subtract, trim, poisson, filter, split

; flags to specify what the operations should do:
duplicates=0            ; Number of duplicates that are tolerated
frag_size=150           ; Estimated fragment size
correction=0.8          ; Fraction of the genome that is mappable
trim_proportion=0.1     ; Fraction of the cluster height below which the peak is trimmed
split_proportion=0.9    ; Fraction of the lower maximum; if the read coverage between two maxima falls below it the peak will be split
height_limit=100        ; After this value the poisson calculation will not assign lower p\-values to the peaks anymore
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Credit
.INDENT 0.0
.IP \(bu 2
Developer: Juan González\-Vallinas
.IP \(bu 2
Testing: Sonja Althammer, Juan González\-Vallinas
.IP \(bu 2
Supervision: Eduardo Eyras
.UNINDENT
.SS Pyicoteolib.core
.sp
Pyicoteolib is the library and the building blocks of the Pyicoteo suite. The pyicoteolib.core library contains the main holders of data in two main objects: ReadCluster and ReadRegion.
.SS ReadCluster
.sp
A ReadCluster object may contain one read or a group of \fBoverlapping\fP reads. It can read both tag like (bed, sam, bam..) and histogram like (wig, bed_pk...) formats. Instances of the ReadCluster object can be added, compared, subtracted to other readCluster objects with standard python syntax.
.sp
The ReadCluster object is optimized in order to deal with millions of overlaps, and has been tested with multiple different HTS datasets. The optimization consists in 2 main principles:
.SS Common python operators
.sp
All the following standard operators are supported:
.SS Adding
.sp
Adding combines the signal of 2 different ReadClusters, with nucleotide precision:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from pyicoteolib.core import ReadCluster, PK

cluster1 = ReadCluster(read=PK)
cluster2 = ReadCluster(read=PK)
cluster1.read_line(\(aqchr1 1 45 9:2.00|41:3.00|50:2.00|45:1.00\(aq)
cluster2.read_line(\(aqchr1 1 125 9:4.00|41:3.00|30:2.00|45:1.00\(aq)
result = cluster1 + cluster2

result.write_line()

chr1    1   145 50:6.00|30:4.00|20:3.00|25:2.00|20:1.00 6.0 .   25  550.0
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Subtracting
.sp
Substracts the signal of 2 different ReadClusters, with nucleotide precision:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from pyicoteolib.core import ReadCluster, SAM, PK

cluster1 = ReadCluster(read=SAM)
cluster2 = ReadCluster(read=PK)
cluster1.read_line(\(aqSL\-XAJ_1_FC305HJAAXX:2:21:872:1402  0   chr1    1   50  36M *   0   0   AAAAGGGGGAATAAAAAGTAACCCAAAACTAACTAT    <<<,7<<<<<7<1:71)<+51<+<5(75()1344+2    PG:Z:FC_305HJAAXX_ln_2.dat\(aq)
cluster2.read_line(\(aqchr1 1 125 9:4.00|41:3.00|30:2.00|45:1.00\(aq)
result = cluster2 \- cluster1

result.write_line()
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Length
.sp
Returns the length of the read cluster:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
c = Cluster(name="chrX", start=1, end=10000)
len(c)

10000
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Comparison operators (< > == !=)
.sp
This indicates which read cluster is before another in a chromosome:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
c1 = Cluster(name="chr1", start=100, end=1000)
c1_copy = Cluster(name="chr1", start=100, end=1000)
c2 = Cluster(name="chr1", start=50000, end=100000)
c1 > c2
False
c1 == c1_copy
True
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Lets see some usage examples.
.SS Read a .bed file, print the chromosome and the length of each read
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from pyicoteolib.core import ReadCluster, BED

bed_file = open("/path/to/myfile.bed")

for line in bed_file:
    rc = ReacCluster(read_as=BED)
    rc.read_line(l)
    print len(rc), rc.area()
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Read some .bed lines, cluster them, output a wiggle file
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from pyicoteolib.core import ReadCluster

cluster =  Cluster(read="bed", write="bed_wig")
cluster.read_line(\(aqchr1 1 20000 id1 0 +\(aq)
cluster.read_line(\(aqchr1 1 20000 id2 0 +\(aq)
cluster.read_line(\(aqchr1 1 20000 id3 0 +\(aq)
cluster.read_line(\(aqchr1 1001 20000 id4 0 +\(aq)
cluster.write_line()
.ft P
.fi
.UNINDENT
.UNINDENT
.SS ReadRegion
.sp
A ReadRegion object holds a genomic region that may contain ReadClusters
.SS pyicoteolib.utils
.SS BAM reader
.SS Credit
.INDENT 0.0
.IP \(bu 2
Developers: Juan González\-Vallinas, Ferran Lloret
.IP \(bu 2
Unit and beta Testing: Juan González\-Vallinas, Ferran Lloret
.IP \(bu 2
Supervision: Eduardo Eyras
.UNINDENT
.SH AUTHOR
Juan González-Vallinas, Ferran Lloret
.SH COPYRIGHT
2013, Regulatory Genomics Group
.\" Generated by docutils manpage writer.
.
